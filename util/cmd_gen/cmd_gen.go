package cmd_gen

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"syscall"
	"unicode"
)

func GenCmd() {
	before, _ := strconv.Atoi(os.Getenv("COMMAND_BEFORE_LEN"))
	if before == 0 {
		fmt.Println("[INFO] Generating all commands...")
	}
	packs, err := parser.ParseDir(token.NewFileSet(), "command", func(info os.FileInfo) bool {
		name := info.Name()
		if info.IsDir() {
			return false
		}
		if name == "zInit.go" {
			return false
		}
		if filepath.Ext(name) != ".go" {
			return false
		}

		if strings.HasSuffix(name, "_test.go") {
			return false
		}
		return true
	}, 0)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	fmt.Fprintln(&buf, "// Code generated by github.com/itzngga/goRoxy DO NOT EDIT.")
	fmt.Fprintln(&buf, `package command

import (
	"github.com/itzngga/goRoxy/internal/handler"
	"github.com/zhangyunhao116/skipmap"
)

var Commands []*handler.Command
var StateMap *skipmap.StringMap[int]

func GetState(number string, types string) (int, bool) {
	return StateMap.Load(number + "-" + types)
}

func SetState(number string, types string, value int) {
	StateMap.Store(number+"-"+types, value)
}

func DelState(number string, types string) {
	StateMap.Delete(number + "-" + types)
}

func GenerateAllCommands() {
	StateMap = skipmap.NewString[int]()
`)

	cmds := 0
	for _, pack := range packs {
		for _, f := range pack.Files {
			for name, object := range f.Scope.Objects {
				if object.Kind == ast.Fun {
					if !strings.Contains(name, "RunFunc") && name != "GenerateAllCommand" && unicode.IsUpper(rune(name[0])) {
						fmt.Fprintln(&buf, "	"+name+"()")
						cmds = cmds + 1
					}
				}
			}
		}
	}
	fmt.Fprintln(&buf, "}\n\nfunc Add(command *handler.Command) {\n\tCommands = append(Commands, command)\n}")
	os.WriteFile("command/zInit.go", buf.Bytes(), 0600)

	if _, err := os.Stat("command/zInit.go"); errors.Is(err, os.ErrNotExist) {
		RestartSelf()
	}

	if before < cmds {
		os.Setenv("COMMAND_BEFORE_LEN", strconv.Itoa(cmds))
		RestartSelf()
	} else {
		os.Setenv("COMMAND_BEFORE_LEN", strconv.Itoa(cmds))
	}
}

func RestartSelf() error {
	self, err := os.Executable()
	if err != nil {
		return err
	}
	args := os.Args
	env := os.Environ()
	// Windows does not support exec syscall.
	if runtime.GOOS == "windows" {
		cmd := exec.Command(self, args[1:]...)
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		cmd.Stdin = os.Stdin
		cmd.Env = env
		err := cmd.Run()
		if err == nil {
			os.Exit(0)
		}
		return err
	}
	return syscall.Exec(self, args, env)
}
